import { __assign, __awaiter, __generator, __values } from 'tslib';
import { HttpClient } from '@angular/common/http';
import { EventEmitter, Directive, forwardRef, ElementRef, NgZone, Input, Output, Renderer2, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { combineLatest } from 'rxjs';
import { map } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/code-block.button.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var codeBlockButtonStyle = "font-family: Menlo, Monaco, Consolas, 'Courier New', monospace;\nfont-size: 12px;\npadding: 14px 12px;\nmargin-bottom: 12px;\nline-height: 1.42857;\nword-break: break-all;\noverflow-wrap: break-word;\nbackground-color: rgb(250, 251, 253);\nborder: 1px solid rgb(234, 236, 240);\nborder-radius: 4px; color: #60a0b0;\nwhite-space: pre-wrap;";
/** @type {?} */
var codeBlockButton = (/**
 * @param {?} context
 * @return {?}
 */
function (context) {
    /** @type {?} */
    var ui = $.summernote.ui;
    // create button
    /** @type {?} */
    var button = ui.button({
        contents: '<i class="note-icon-frame" style="margin-right: 4px"></i> Code block',
        tooltip: 'Add code block',
        container: '.note-editor',
        className: 'note-btn',
        click: (/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var selectedText = null;
            // The below code will copy the selected block and add it into our code block
            if (window.getSelection) {
                selectedText = window
                    .getSelection()
                    .toString()
                    .replace(/^\s+|\s+$/g, '');
            }
            /** @type {?} */
            var codeText = selectedText ? selectedText : "Place your code here.";
            /** @type {?} */
            var codeBlock = "<pre class=\"code-block\" style=\"" + codeBlockButtonStyle + "\">" + codeText + "</pre>";
            context.invoke('editor.pasteHTML', codeBlock);
        })
    });
    return button.render(); // return button as jquery object
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ngx-summernote.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxSummernoteDirective = /** @class */ (function () {
    function NgxSummernoteDirective(el, zone, http) {
        this.el = el;
        this.zone = zone;
        this.http = http;
        // summernoteModel directive as output: update model if editor contentChanged
        this.summernoteModelChange = new EventEmitter();
        this.imageUpload = new EventEmitter();
        this.mediaDelete = new EventEmitter();
        // // summernoteInit directive as output: send manual editor initialization
        // @Output() summernoteInit: EventEmitter<Object> = new EventEmitter<Object>();
        this.blur = new EventEmitter();
        this._options = {};
        this.SPECIAL_TAGS = ['img', 'button', 'input', 'a'];
        this.INNER_HTML_ATTR = 'innerHTML';
        this._oldModel = null;
        // Begin ControlValueAccesor methods.
        this.onChange = (/**
         * @param {?} _
         * @return {?}
         */
        function (_) { });
        this.onTouched = (/**
         * @return {?}
         */
        function () { });
        /** @type {?} */
        var element = el.nativeElement;
        // check if the element is a special tag
        if (this.SPECIAL_TAGS.indexOf(element.tagName.toLowerCase()) !== -1) {
            this._hasSpecialTag = true;
        }
        // jquery wrap and store element
        // this._$element = <any>$(element);
        this.zone = zone;
    }
    Object.defineProperty(NgxSummernoteDirective.prototype, "ngxSummernote", {
        set: /**
         * @param {?} options
         * @return {?}
         */
        function (options) {
            var _this = this;
            if (options) {
                if (!options.buttons) {
                    options.buttons = {};
                }
                options.callbacks = __assign({}, options.callbacks, { onImageUpload: (/**
                     * @param {?} files
                     * @return {?}
                     */
                    function (files) { return _this.uploadImage(files); }), onMediaDelete: (/**
                     * @param {?} files
                     * @return {?}
                     */
                    function (files) {
                        return _this.mediaDelete.emit({ url: $(files[0]).attr('src') });
                    }) });
                // add custom buttons
                options.buttons.codeBlock = codeBlockButton;
                Object.assign(this._options, options);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxSummernoteDirective.prototype, "summernoteModel", {
        // summernoteModel directive as input: store initial editor content
        set: 
        // summernoteModel directive as input: store initial editor content
        /**
         * @param {?} content
         * @return {?}
         */
        function (content) {
            this.updateEditor(content);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NgxSummernoteDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.createEditor();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    NgxSummernoteDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (this._editorInitialized && changes) {
            if (changes.ngxSummernoteDisabled &&
                !changes.ngxSummernoteDisabled.firstChange &&
                changes.ngxSummernoteDisabled.currentValue !==
                    changes.ngxSummernoteDisabled.previousValue) {
                if (changes.ngxSummernoteDisabled.currentValue) {
                    this._$element.summernote('disable');
                }
                else {
                    this._$element.summernote('enable');
                }
            }
        }
    };
    /**
     * @return {?}
     */
    NgxSummernoteDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroyEditor();
        if (this.uploadSub) {
            this.uploadSub.unsubscribe();
        }
    };
    // Form model content changed.
    // Form model content changed.
    /**
     * @param {?} content
     * @return {?}
     */
    NgxSummernoteDirective.prototype.writeValue = 
    // Form model content changed.
    /**
     * @param {?} content
     * @return {?}
     */
    function (content) {
        this.updateEditor(content);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NgxSummernoteDirective.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NgxSummernoteDirective.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouched = fn;
    };
    // Update editor with model contents.
    // Update editor with model contents.
    /**
     * @private
     * @param {?} content
     * @return {?}
     */
    NgxSummernoteDirective.prototype.updateEditor = 
    // Update editor with model contents.
    /**
     * @private
     * @param {?} content
     * @return {?}
     */
    function (content) {
        if (JSON.stringify(this._oldModel) === JSON.stringify(content)) {
            return;
        }
        this._oldModel = content;
        // this._$element.html(content);
        if (this._editorInitialized) {
            this._$element.summernote('code', content);
        }
        else {
            this._$element.html(content);
        }
    };
    // update model if editor contentChanged
    // update model if editor contentChanged
    /**
     * @private
     * @param {?=} content
     * @return {?}
     */
    NgxSummernoteDirective.prototype.updateModel = 
    // update model if editor contentChanged
    /**
     * @private
     * @param {?=} content
     * @return {?}
     */
    function (content) {
        var _this = this;
        // console.log('update model', content)
        this.zone.run((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var modelContent = null;
            if (_this._hasSpecialTag) {
                /** @type {?} */
                var attributeNodes = _this._$element[0].attributes;
                /** @type {?} */
                var attrs = {};
                for (var i = 0; i < attributeNodes.length; i++) {
                    /** @type {?} */
                    var attrName = attributeNodes[i].name;
                    if (_this._options.angularIgnoreAttrs &&
                        _this._options.angularIgnoreAttrs.indexOf(attrName) !== -1) {
                        continue;
                    }
                    attrs[attrName] = attributeNodes[i].value;
                }
                if (_this._$element[0].innerHTML) {
                    attrs[_this.INNER_HTML_ATTR] = _this._$element[0].innerHTML;
                }
                modelContent = attrs;
            }
            else {
                /** @type {?} */
                var returnedHtml = content || '';
                if (typeof returnedHtml === 'string') {
                    modelContent = returnedHtml;
                }
            }
            if (_this._oldModel !== modelContent) {
                _this._oldModel = modelContent;
                // Update summernoteModel
                _this.summernoteModelChange.emit(modelContent);
                // Update form model.
                _this.onChange(content);
            }
        }));
    };
    /**
     * @private
     * @return {?}
     */
    NgxSummernoteDirective.prototype.initListeners = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        if (!this._$element) {
            return;
        }
        this._$element.on('summernote.init', (/**
         * @return {?}
         */
        function () {
            setTimeout((/**
             * @return {?}
             */
            function () {
                self.updateModel();
            }), 0);
        }));
        this._$element.on('summernote.change', (/**
         * @param {?} event
         * @param {?} contents
         * @param {?} $editable
         * @return {?}
         */
        function (event, contents, $editable) {
            setTimeout((/**
             * @return {?}
             */
            function () {
                self.updateModel(contents);
            }), 0);
        }));
        this._$element.on('summernote.blur', (/**
         * @return {?}
         */
        function () {
            setTimeout((/**
             * @return {?}
             */
            function () {
                self.onTouched();
                self.blur.emit();
            }), 0);
        }));
        if (this._options.immediateAngularModelUpdate) {
            this._editor.on('keyup', (/**
             * @return {?}
             */
            function () {
                setTimeout((/**
                 * @return {?}
                 */
                function () {
                    self.updateModel();
                }), 0);
            }));
        }
    };
    /**
     * @private
     * @return {?}
     */
    NgxSummernoteDirective.prototype.createEditor = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._editorInitialized) {
            return;
        }
        this.setContent(true);
        /** @type {?} */
        var wait = 50;
        // this.initListeners(); // issue #31
        try {
            this._$element = (/** @type {?} */ ($(this.el.nativeElement)));
        }
        catch (error) {
            console.log("JQuery seems not te loaded yet! Wait " + wait + "ms and try again");
        }
        if (!this._$element) {
            setTimeout((/**
             * @return {?}
             */
            function () {
                _this.createEditor();
            }), wait);
        }
        else {
            // init editor
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                _this._editor = _this._$element
                    .summernote(_this._options)
                    .data('summernote').$note;
                _this.initListeners(); // issue #31
                if (_this.ngxSummernoteDisabled) {
                    _this._$element.summernote('disable');
                }
            }));
            this._editorInitialized = true;
        }
    };
    /**
     * @private
     * @return {?}
     */
    NgxSummernoteDirective.prototype.setHtml = /**
     * @private
     * @return {?}
     */
    function () {
        this._$element.summernote('code', this._model || '', true);
    };
    /**
     * @private
     * @param {?=} firstTime
     * @return {?}
     */
    NgxSummernoteDirective.prototype.setContent = /**
     * @private
     * @param {?=} firstTime
     * @return {?}
     */
    function (firstTime) {
        if (firstTime === void 0) { firstTime = false; }
        // console.log('set content', firstTime, this._oldModel, this._model)
        /** @type {?} */
        var self = this;
        // Set initial content
        if (this._model || this._model === '') {
            this._oldModel = this._model;
            if (this._hasSpecialTag) {
                /** @type {?} */
                var tags = this._model;
                // add tags on element
                if (tags) {
                    for (var attr in tags) {
                        if (tags.hasOwnProperty(attr) && attr !== this.INNER_HTML_ATTR) {
                            this._$element.attr(attr, tags[attr]);
                        }
                    }
                    if (tags.hasOwnProperty(this.INNER_HTML_ATTR)) {
                        this._$element[0].innerHTML = tags[this.INNER_HTML_ATTR];
                    }
                }
            }
            else {
                self.setHtml();
            }
        }
    };
    /**
     * @private
     * @return {?}
     */
    NgxSummernoteDirective.prototype.destroyEditor = /**
     * @private
     * @return {?}
     */
    function () {
        if (this._editorInitialized) {
            this._editor.off('keyup');
            this._$element.summernote('destroy'); // TODO not sure it works now...
            this._editorInitialized = false;
        }
    };
    // private getEditor() {
    //   if (this._$element) {
    //     return this._$element.summernote.bind(this._$element);
    //   }
    //   return null;
    // }
    // private getEditor() {
    //   if (this._$element) {
    //     return this._$element.summernote.bind(this._$element);
    //   }
    //   return null;
    // }
    /**
     * @private
     * @param {?} files
     * @return {?}
     */
    NgxSummernoteDirective.prototype.uploadImage = 
    // private getEditor() {
    //   if (this._$element) {
    //     return this._$element.summernote.bind(this._$element);
    //   }
    //   return null;
    // }
    /**
     * @private
     * @param {?} files
     * @return {?}
     */
    function (files) {
        return __awaiter(this, void 0, void 0, function () {
            var e_1, _a, requests, files_1, files_1_1, file, data, obs;
            var _this = this;
            return __generator(this, function (_b) {
                if (this._options.uploadImagePath) {
                    this.imageUpload.emit({ uploading: true });
                    requests = [];
                    try {
                        for (files_1 = __values(files), files_1_1 = files_1.next(); !files_1_1.done; files_1_1 = files_1.next()) {
                            file = files_1_1.value;
                            data = new FormData();
                            data.append('image', file);
                            obs = this.http
                                .post(this._options.uploadImagePath, data, this._options.uploadImageRequestOptions)
                                .pipe(map((/**
                             * @param {?} response
                             * @return {?}
                             */
                            function (response) {
                                return response && typeof response.path === 'string' && response.path;
                            })));
                            requests.push(obs);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (files_1_1 && !files_1_1.done && (_a = files_1.return)) _a.call(files_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    this.uploadSub = combineLatest(requests).subscribe((/**
                     * @param {?} remotePaths
                     * @return {?}
                     */
                    function (remotePaths) {
                        var e_2, _a;
                        try {
                            for (var remotePaths_1 = __values(remotePaths), remotePaths_1_1 = remotePaths_1.next(); !remotePaths_1_1.done; remotePaths_1_1 = remotePaths_1.next()) {
                                var remotePath = remotePaths_1_1.value;
                                _this._$element.summernote('insertImage', remotePath);
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (remotePaths_1_1 && !remotePaths_1_1.done && (_a = remotePaths_1.return)) _a.call(remotePaths_1);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        _this.imageUpload.emit({ uploading: false });
                    }), (/**
                     * @param {?} err
                     * @return {?}
                     */
                    function (err) { return _this.insertFromDataURL(files); }));
                }
                else {
                    this.insertFromDataURL(files);
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * @param {?} files
     * @return {?}
     */
    NgxSummernoteDirective.prototype.insertFromDataURL = /**
     * @param {?} files
     * @return {?}
     */
    function (files) {
        var _this = this;
        var e_3, _a;
        var _loop_1 = function (file) {
            /** @type {?} */
            var reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = (/**
             * @return {?}
             */
            function () {
                _this._$element.summernote('insertImage', reader.result);
                _this.imageUpload.emit({ uploading: false, encoding: 'base64' });
            });
            reader.onerror = (/**
             * @param {?} error
             * @return {?}
             */
            function (error) { return console.error(error); });
        };
        try {
            for (var files_2 = __values(files), files_2_1 = files_2.next(); !files_2_1.done; files_2_1 = files_2.next()) {
                var file = files_2_1.value;
                _loop_1(file);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (files_2_1 && !files_2_1.done && (_a = files_2.return)) _a.call(files_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    NgxSummernoteDirective.decorators = [
        { type: Directive, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: '[ngxSummernote]',
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return NgxSummernoteDirective; })),
                            multi: true
                        }
                    ]
                },] }
    ];
    /** @nocollapse */
    NgxSummernoteDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone },
        { type: HttpClient }
    ]; };
    NgxSummernoteDirective.propDecorators = {
        ngxSummernote: [{ type: Input }],
        summernoteModel: [{ type: Input }],
        summernoteModelChange: [{ type: Output }],
        imageUpload: [{ type: Output }],
        mediaDelete: [{ type: Output }],
        blur: [{ type: Output }],
        ngxSummernoteDisabled: [{ type: Input }]
    };
    return NgxSummernoteDirective;
}());
if (false) {
    /** @type {?} */
    NgxSummernoteDirective.prototype.summernoteModelChange;
    /** @type {?} */
    NgxSummernoteDirective.prototype.imageUpload;
    /** @type {?} */
    NgxSummernoteDirective.prototype.mediaDelete;
    /** @type {?} */
    NgxSummernoteDirective.prototype.blur;
    /** @type {?} */
    NgxSummernoteDirective.prototype.ngxSummernoteDisabled;
    /**
     * @type {?}
     * @private
     */
    NgxSummernoteDirective.prototype._options;
    /**
     * @type {?}
     * @private
     */
    NgxSummernoteDirective.prototype.SPECIAL_TAGS;
    /**
     * @type {?}
     * @private
     */
    NgxSummernoteDirective.prototype.INNER_HTML_ATTR;
    /**
     * @type {?}
     * @private
     */
    NgxSummernoteDirective.prototype._hasSpecialTag;
    /**
     * @type {?}
     * @private
     */
    NgxSummernoteDirective.prototype._$element;
    /**
     * @type {?}
     * @private
     */
    NgxSummernoteDirective.prototype._editor;
    /**
     * @type {?}
     * @private
     */
    NgxSummernoteDirective.prototype._model;
    /**
     * @type {?}
     * @private
     */
    NgxSummernoteDirective.prototype._oldModel;
    /**
     * @type {?}
     * @private
     */
    NgxSummernoteDirective.prototype._editorInitialized;
    /**
     * @type {?}
     * @private
     */
    NgxSummernoteDirective.prototype.uploadSub;
    /** @type {?} */
    NgxSummernoteDirective.prototype.onChange;
    /** @type {?} */
    NgxSummernoteDirective.prototype.onTouched;
    /**
     * @type {?}
     * @private
     */
    NgxSummernoteDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    NgxSummernoteDirective.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    NgxSummernoteDirective.prototype.http;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ngx-summernote-view.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxSummernoteViewDirective = /** @class */ (function () {
    function NgxSummernoteViewDirective(renderer2, element) {
        this.renderer2 = renderer2;
        this._element = element.nativeElement;
    }
    Object.defineProperty(NgxSummernoteViewDirective.prototype, "ngxSummernoteView", {
        set: /**
         * @param {?} content
         * @return {?}
         */
        function (content) {
            this._element.innerHTML = content || '';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NgxSummernoteViewDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.renderer2.addClass(this._element, 'ngx-summernote-view');
    };
    NgxSummernoteViewDirective.decorators = [
        { type: Directive, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: '[ngxSummernoteView]'
                },] }
    ];
    /** @nocollapse */
    NgxSummernoteViewDirective.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    NgxSummernoteViewDirective.propDecorators = {
        ngxSummernoteView: [{ type: Input }]
    };
    return NgxSummernoteViewDirective;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgxSummernoteViewDirective.prototype._element;
    /**
     * @type {?}
     * @private
     */
    NgxSummernoteViewDirective.prototype.renderer2;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ngx-summernote.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxSummernoteModule = /** @class */ (function () {
    function NgxSummernoteModule() {
    }
    /**
     * @return {?}
     */
    NgxSummernoteModule.forRoot = /**
     * @return {?}
     */
    function () {
        return { ngModule: NgxSummernoteModule, providers: [] };
    };
    NgxSummernoteModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        NgxSummernoteDirective,
                        NgxSummernoteViewDirective
                    ],
                    exports: [
                        NgxSummernoteDirective,
                        NgxSummernoteViewDirective
                    ]
                },] }
    ];
    return NgxSummernoteModule;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngx-summernote.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxSummernoteDirective, NgxSummernoteModule, NgxSummernoteViewDirective, codeBlockButton };
//# sourceMappingURL=ngx-summernote.js.map
